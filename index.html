<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>æ”¾é¬†æ–¹å¡Šï½œé•·è¼©ç‰ˆ Touch</title>
<style>
body {
  background-color: #fff8ef;
  font-family: "Noto Sans TC", sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  margin: 0;
  height: 100vh;
  user-select: none;
  touch-action: none;
}
h1 {
  color: #ff914d;
  margin: 10px 0;
  font-size: 32px;
}
.board {
  display: grid;
  background: #ffe2c4;
  gap: 4px;
  border-radius: 12px;
  margin-top: 10px;
  position: relative;
}
.cell {
  width: 36px;
  height: 36px;
  background: #fff6e6;
  border-radius: 6px;
}
.cell.filled { background: #ffb877; transition: background 0.2s; }
.cell.hint { animation: blink 0.5s ease-in-out infinite alternate; }
@keyframes blink {
  from { background: rgba(255,183,119,0.3); }
  to { background: rgba(255,183,119,0.9); }
}
.controls, .info {
  margin: 10px;
  text-align: center;
  font-size: 20px;
  color: #444;
}
button {
  background: #ffb877;
  color: white;
  border: none;
  border-radius: 10px;
  padding: 12px 20px;
  margin: 5px;
  font-size: 20px;
}
button:active { background: #ffc999; }
.blocks {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 15px;
}
.shape {
  display: grid;
  gap: 3px;
  background: transparent;
  border-radius: 8px;
  padding: 5px;
  position: relative;
  transition: transform 0.2s ease;
}
.shape-cell {
  width: 30px;
  height: 30px;
  background: #ffb877;
  border-radius: 4px;
}
.shape.dragging {
  opacity: 0.9;
  position: absolute;
  z-index: 999;
  transform: scale(1.1);
}
</style>
</head>
<body>
  <a href="relax.html">æ”¾é¬†æ¨¡å¼</a>
<h1>ğŸ§¡ æ”¾é¬†æ–¹å¡Š</h1>
<div class="info">
  <div>åˆ†æ•¸ï¼š<span id="score">0</span>ã€€æœ€ä½³ï¼š<span id="best">0</span></div>
  <div>æ™‚é–“ï¼š<span id="time">0</span> ç§’</div>
</div>
<div class="controls">
  <button id="modeBtn">æ¨¡å¼ï¼š5x5</button>
  <button id="relaxBtn">æ”¾é¬†æ¨¡å¼ï¼šé—œ</button>
  <button id="hintBtn">ğŸ’¡ çµ¦æˆ‘æç¤º</button>
  <button id="restartBtn">é‡æ–°é–‹å§‹</button>
</div>
<div class="board"></div>
<div class="blocks"></div>
<audio id="clearSound" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_8e95f7a56e.mp3?filename=correct-2-46134.mp3"></audio>

<script>
const boardEl = document.querySelector('.board');
const blocksEl = document.querySelector('.blocks');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const timeEl = document.getElementById('time');
const clearSound = document.getElementById('clearSound');
let boardSize = 5;
let board = [];
let score = 0;
let best = parseInt(localStorage.getItem('best_block')) || 0;
let startTime = Date.now();
let relaxMode = false;
let idleTimer;
let currentShapes = [];
bestEl.textContent = best;

const SHAPES = [
  [[1]], [[1,1]], [[1,1,1]], [[1],[1],[1]],
  [[1,1],[1,0]], [[1,1],[0,1]],
  [[1,1,1],[0,1,0]], [[1,1,1],[1,0,0]], [[0,1,1],[1,1,0]]
];

function initBoard() {
  board = Array.from({length: boardSize}, () => Array(boardSize).fill(0));
  boardEl.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
  renderBoard();
  generateShapes();
}

function renderBoard() {
  boardEl.innerHTML = '';
  board.flat().forEach(v => {
    const c = document.createElement('div');
    c.className = 'cell';
    if (v) c.classList.add('filled');
    boardEl.appendChild(c);
  });
}

function generateShapes() {
  while (currentShapes.length < 3) {
    const s = SHAPES[Math.floor(Math.random()*SHAPES.length)];
    currentShapes.push(s);
  }
  renderShapes();
  checkGameOver();
}

function renderShapes() {
  blocksEl.innerHTML = '';
  currentShapes.forEach(s=>{
    const div = document.createElement('div');
    div.className = 'shape';
    div.style.gridTemplateColumns = `repeat(${s[0].length}, 1fr)`;
    s.flat().forEach(v=>{
      const sc = document.createElement('div');
      sc.className='shape-cell';
      if(!v) sc.style.visibility='hidden';
      div.appendChild(sc);
    });
    enableDragTouch(div, s);
    blocksEl.appendChild(div);
  });
}

function enableDragTouch(el, shape) {
  let dragging = false;
  el.addEventListener('touchstart', e=>{
    const t = e.touches[0];
    dragging = true;
    el.classList.add('dragging');
    el.style.left = `${t.clientX - el.offsetWidth / 2}px`;
    el.style.top = `${t.clientY - el.offsetHeight / 2}px`;
    document.body.appendChild(el);
    resetIdleTimer();
  });

  el.addEventListener('touchmove', e=>{
    if(!dragging) return;
    const t = e.touches[0];
    el.style.left = `${t.clientX - el.offsetWidth / 2}px`;
    el.style.top = `${t.clientY - el.offsetHeight / 2}px`;
  });

  el.addEventListener('touchend', e=>{
    dragging = false;
    const t = e.changedTouches[0];
    const rect = boardEl.getBoundingClientRect();
    const size = rect.width / boardSize;
    const offsetX = t.clientX - rect.left;
    const offsetY = t.clientY - rect.top;
    const x = Math.round(offsetX / size - shape[0].length/2);
    const y = Math.round(offsetY / size - shape.length/2);
    let placed = false;

    if (x>=0 && y>=0 && x+shape[0].length<=boardSize && y+shape.length<=boardSize && canPlace(shape, y, x)) {
      placeShape(shape, y, x);
      score += 5;
      scoreEl.textContent = score;
      checkClear();
      currentShapes.splice(currentShapes.indexOf(shape),1);
      generateShapes();
      placed = true;
    }

    el.classList.remove('dragging');
    el.style.position = '';
    el.style.left = '';
    el.style.top = '';
    el.style.opacity = '1';

    if(!placed){
      blocksEl.appendChild(el);
    } else {
      el.remove();
    }
    resetIdleTimer();
  });
}

function placeShape(shape, row, col) {
  for (let r=0;r<shape.length;r++){
    for (let c=0;c<shape[r].length;c++){
      if(shape[r][c]) board[row+r][col+c]=1;
    }
  }
  renderBoard();
}

function canPlace(shape, row, col) {
  for (let r=0;r<shape.length;r++){
    for (let c=0;c<shape[r].length;c++){
      if(!shape[r][c]) continue;
      if(row+r>=boardSize || col+c>=boardSize || board[row+r][col+c]) return false;
    }
  }
  return true;
}

function checkClear() {
  let lines = 0;
  for (let i=0;i<boardSize;i++){
    if(board[i].every(v=>v===1)){ board[i].fill(0); lines++; }
    if(board.map(r=>r[i]).every(v=>v===1)){ for(let r=0;r<boardSize;r++) board[r][i]=0; lines++; }
  }
  if(lines>0){
    score += lines*10;
    scoreEl.textContent = score;
    clearSound.play();
    renderBoard();
  }
  if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('best_block',best); }
}

function startTimer() {
  setInterval(()=>{ timeEl.textContent=Math.floor((Date.now()-startTime)/1000); },1000);
}

// ğŸ”¦ æç¤ºåŠŸèƒ½
function showHint() {
  clearHints();
  for (let s of currentShapes){
    for(let y=0;y<boardSize;y++){
      for(let x=0;x<boardSize;x++){
        if(canPlace(s,y,x)){
          highlightHint(s,y,x);
          playVoice("è©¦è©¦çœ‹é€™å€‹å½¢ç‹€ï½");
          return;
        }
      }
    }
  }
  gameOver();
}

function highlightHint(shape,row,col){
  const cells = [...boardEl.children];
  for(let r=0;r<shape.length;r++){
    for(let c=0;c<shape[r].length;c++){
      if(!shape[r][c]) continue;
      const idx = (row+r)*boardSize + (col+c);
      const cell = cells[idx];
      if(cell) cell.classList.add('hint');
    }
  }
  setTimeout(clearHints,3000);
}

function clearHints(){
  document.querySelectorAll('.cell.hint').forEach(c=>c.classList.remove('hint'));
}

// â° 6ç§’æ²’æ“ä½œè‡ªå‹•æç¤º
function resetIdleTimer(){
  clearTimeout(idleTimer);
  idleTimer = setTimeout(showHint,6000);
}

// ğŸ¤ èªéŸ³æ’­æ”¾
function playVoice(text){
  const synth = window.speechSynthesis;
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = "zh-TW";
  synth.speak(utter);
}

// ğŸ§© æ²’åœ°æ–¹æ”¾å°±çµæŸ
function checkGameOver(){
  for (let s of currentShapes){
    for(let y=0;y<boardSize;y++){
      for(let x=0;x<boardSize;x++){
        if(canPlace(s,y,x)) return;
      }
    }
  }
  gameOver();
}

function gameOver(){
  playVoice("éŠæˆ²çµæŸå›‰ï½");
  alert("ğŸ‰ éŠæˆ²çµæŸå›‰ï½ ç¸½åˆ†ï¼š"+score);
  if(score>best){ best=score; localStorage.setItem('best_block',best); }
  restart();
}

document.getElementById('modeBtn').onclick=()=>{
  boardSize = boardSize===5 ? 8 : boardSize===8 ? 10 : 5;
  document.getElementById('modeBtn').textContent=`æ¨¡å¼ï¼š${boardSize}x${boardSize}`;
  restart();
};
document.getElementById('relaxBtn').onclick=()=>{
  relaxMode = !relaxMode;
  document.getElementById('relaxBtn').textContent = `æ”¾é¬†æ¨¡å¼ï¼š${relaxMode?"é–‹":"é—œ"}`;
};
document.getElementById('restartBtn').onclick=()=>restart();
document.getElementById('hintBtn').onclick=()=>showHint();

function restart() {
  score=0;
  scoreEl.textContent=0;
  startTime=Date.now();
  initBoard();
  resetIdleTimer();
}

initBoard();
startTimer();
resetIdleTimer();
</script>
</body>
</html>
